# 재귀 방식으로 호출하면 같은 함수가 여러번 호출 된다 따라서 별로다 .

def fibo(x) :
    if x==1 or x==2 :
        return 1 
    return fibo(x-1) + fibo(x-2)

print(fibo(4))

# 동적 계획법으로 호출 방법
# 조건 2가지 
# 1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있습니다.
# 2. 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결합니다.
# 조건 만족시 구현 방법
# - 메모이제이션
# 한번 계싼한 결과를 메모리 공간에 메모하는 기법 
# 두가지 방법 , 탑다운(하향식) VS 보텀업(상향식)

d =[0] *100 
# 탑 다운 / 하향식 다이나믹 프로그래밍 
def fibo2(x):
    # 종료 조건(1 혹은 2 일 떄 1을 반환)
    if x ==1 or x ==2 :
        return 1 
    
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] !=0:
        return d[x]
    
    # 계산한적 없다면 점화식에 따라 결과 반환 
    d[x] = fibo(x-1) + fibo(x-2)
    return d[x]

print(fibo2(99))

# dp 테이블 초기화 
d =[0] *100 
# 1,2 번쨰 피보나치 수는 1 
d[1] =1 
d[2] =1
n = 99 

# 피보나치 함수 반복문으로 구현 (바텀업 / 상향식 )

for i in range(3,n+1):
    d[i] = d[i-1] +d[i-2]

print(d[n])

